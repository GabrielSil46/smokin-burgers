import random
import time
from playsound import playsound
import asyncio
## eu tinha copiado o codigo pro clipboard mas quando eu colei n foi kkkkkkkkkkk
## deu o maior cagaço
## kkkkkkkk
## mds
## ta desculpa chefe n fasso mas isso
## :flushed_face:
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠉⠁⠀⠀⠀ ⠀⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠘⢿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⣾⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⠋⠈⠀⠀⠀⠀⠐⠺⣖⢄⠀⠀⠀⠀⠀  ⠀⠀⠀⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡏⢀⡆⠀⠀⠀⢋⣭⣽⡚⢮⣲⠆⠀⠀⠀ ⠀⠀⠀⢹⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡇⡼⠀⠀⠀⠀⠈⠻⣅⣨⠇⠈⠀ ⠰⣀⣀⣀⡀⠀⢸⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡇⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⣟⢷⣶⠶⣃⢀⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⢿⠀⠈⠓⠚⢸⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⢀⡠⠀⡄⣀⠀⠀  ⠀⢻⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠐⠉⠀⠀⠙⠉⠀ ⠠⡶⣸⠁⠀⣠⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣦⡆⠀⠐⠒⠢⢤⣀⡰⠁⠇⠈⠘⢶⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠠⣄⣉⣙⡉⠓⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄ ⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣀⠀⣀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
## era pra ser o the rock kkkkk
## kkkkkkk
## uma merda
## sim. \n agora vou voltar a trabalhar chefe

## fino señores ## :pinched_fingers:

# kkkkkkkk cagaço insano
# eu até falei no chat com medo de n funcionar o ctrl z
# ah bom vou ficar d olho :eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome::eyeemojinseionome:
# :ox:
# o que ser isso
# aah kkkkkkk ficou parecendo uma trollface
# assim q e bom
# tabom ah bom

## quer tentar fazer a ascii art para o jogo enquanto eu trabalho em conectar esse emaranhado de função?
## ok
## baixa o paint.net é bão
## ss vou pegar
## https://portableapps.com/apps/graphics_pictures/paintdotnet-portable
## n é oficial mas o portableapps é bom tb
## :ok_hand:
## ss, vou tentar
## tem o link do portable?
## https://github.com/paintdotnet/release/releases/tag/v4.3.12 esse aqui tbm serve? \n creio q sim
## uhum
## ss
## esse é o oficial né?
## serve
## talvez seja até melhor msm

##############################################################################################################

####################
# GLOBAL VARIABLES #
####################

days = 0
size = 0

comandoChapa = 'XX' ## o primeiro índice referencia o hamburguer, o segundo a ação a ser tomada
asmbIng = {0: 'down-bread', 1: 'top-bread', 2: 'burger', 3: 'cheese', 4: 'lettuce', 5: 'tomato', 6: [0, 0, 0, 0, 0, 0, 0]}
## update! asmbIng[6][6] is how well the burger is cooked (ranges from 0 to 200)
## for exclusive use by buildStation()! using asmbIng anywhere else will potentially break the code.

ingameTime = 0
customersWaiting = 0
orders = []
burgers = []
grill = [] 
cookedPatties = []
customerArrivalTimes = []


##############################################################################################################

#######################
# ACCESSORY FUNCTIONS #
#######################
### miscellaneous functions that are repeated throughout the code ###

def printStationMessage(station, topMessage, commands=False):
    global ingameTime ## to be used in the future for implementing a clock mechanic to the station message

    stationASCII = {"a": "alguma arte ascii", "b": "blah", "c": "blegh"} ## a for grill, b for build, c for checkout
    ## this will store the ASCII art in the future
    print(stationASCII[station])
    print(topMessage)
    print('=-'*30, end='=\n')
    print("""-=- NAVIGATION -=-
    A: GRILL STATION
    B: BUILD STATION
    C: CHECKOUT COUNTER""")
    if commands:
        print('-=- ACTIONS -=-')
        print(commands)
        print('v: view current orders')
        print('=-'*30, end='=\n')


def navigation(currentStation, command):
    stations = {"a": grillStation, "b": buildStation, "c": checkoutStation}
    command = command.strip().lower()
    if command not in 'abc':
        print('YOU PICKED THE WRONG COMMAND, FOOL!')
        stations[currentStation]()
    stations[command]()


##############################################################################################################

###################
# ASYNC FUNCTIONS #
###################
### the counter functions! they run asynchronously. ###

# isso po trabaia ai meu funcionario vou ficar aqui olhando
## ta aqui
aumento = 0
aumento += 0.0001 / 2
# :thumbsup:
# kkkkkkkkkkkkkkkkkkkkkkkk

async def burgerTimeCounter(burgerID):
    """
    this function handles:
    - writes to global var "grill" the cook percentage of each side
    - removing the patty
    - flipping the patty
    - counts time spent on grill and sets random time for ideal cook percentage
    """
    global comandoChapa
    global grill
    burgerSide = 0 ## 0 para o lado de baixo e 1 para o lado de cima
    tempoPraAssar = 16 * (random.randint(8, 12) / 10) ## hambúrguer pode levar de 12.8s até 19.2s para assar (intervalo muito largo?)

    while(comandoChapa[0] != burgerID):
        grill[burgerID][burgerSide] += 100 / (tempoPraAssar * 4)
        time.sleep(0.25)
    
    if comandoChapa[1] == '0':
        if burgerSide:
            burgerSide = 0
        else:
            burgerSide = 1
    elif comandoChapa[1] == '1':
        cookedPatties.append(sum(grill[burgerID]) / 2)
        grill.pop(burgerID)
        ## update! agora a média de cozimento é simplesmente a soma do cozimento dos dois lados do hambúrguer 
        ## soma de 200% é totalmente queimado (100% cada lado)


async def ingameTimeCounter():
    """
    this function handles:
    - keeping track of ingame time
    - async customer arrivals
    """
    global ingameTime
    global customerArrivalTimes

    while(ingameTime < 180):
        time.sleep(1)
        ingameTime += 1

        if customerArrivalTimes[0] >= ingameTime:
            print('Um cliente chegou para fazer um pedido!')
            orders.append(makeOrder())
            customerArrivalTimes.pop(0)

    print('DAY OVER!')


##############################################################################################################

############################
# CUSTOMER ORDER FUNCTIONS #
############################

def viewOrders():
    global orders
    ing = {0: 'burger', 1: 'cheese', 2: 'lettuce', 3: 'tomato'}
    ## o nome do cliente está em order[1], e o seu pedido em order[0]
    for orderNumber, order in enumerate(orders):
        print(f'Order number {orderNumber}, from {order[1]}, says:')
        for ingIndex, ingQuantity in enumerate(order[0]):
            if ingQuantity > 0:
                print(ingQuantity, ing[ingIndex])

    if len(orders) == 0:
        print('no customer orders to view... for now. no slacking or você será avisado.')


# função para o pedido do cliente
## modifiquei essa função de forma que ela é apenas responsável por gerar um pedido aleatório, ficou mais como um acessório
## para outras funções.
def makeOrder(size):
    names = ['sussy oliveira', 'ednalva', 'lula', 'big smoke', 'walter white', 'jesse pinkman', 'davi', 'joão', 'samuel', 'xandao cabeça de p']
    global orders
    ing = [0, 0, 0, 0]
    
    for _ in range(size):
        ing[random.randint(0, 3)] += 1

    orders.append([ing, random.choice(names), ingameTime])


# função para a entrega e avaliação do pedido
def rateBurger(order, burger, wait_secs, somaDeCozimento):
    prices = {0: 3, 1: 2.25, 2: 1.50, 3: 1.75} ## preço de cada ingrediente (hamburguer, queijo, alface e tomate; respectivamente)
    final_price = 0
    penalty = 0
    satisfaction_level = 100 ## level de satisfacao maximo
    wait_secsfull = 60 # tempo de espera padrao - tempo de espera, quanto mais proximo de 0, pior
    rate = 5

    burgerArr = burger[0] ## asmbIng[6]
    burgerArr.pop(0)
    burgerArr.pop(1) ## removes top-bread and down-bread (they will not be taken into account for the rating)
    print(burgerArr)

    for ind, val in enumerate(burgerArr): ## calcula o preço do hambúrguer de acordo com os ingredientes
        final_price += prices[ind] * val
        ## se a quantidade de um tipo de ingrediente n for igual à pedida;
        if order[ind] > val: ## se o pedido queria mais de um ingrediente
            penalty += (order[ind] - val)*2
        elif order[ind] < val: ## se queria menos
            penalty += val - order[ind] # pensar em algo melhor dps ## adicionar a penalty a quantidade de ingredientes errados.
    
    final_price += 2 # bread's expenses

    # aviso: tudo o que envolve o algoritmo de satisfação do cliente nessa função está wip ou é placeholder, ou seja: completamente bugado
    ## finalsatisfaction = penalidade (número de ingredientes incorretos) menos o tempo remanescente de espera
    print(penalty)
    dissatisfaction = (penalty * 15) + (wait_secsfull - wait_secs) # atual formula de penalidade, apenas placeholder, pensar em uma melhor dps
    final_stats = satisfaction_level - dissatisfaction ## satisfacao total (satisfacao maxima - quantidade de satisfacao perdida)
    if final_stats < 0:
        final_stats = 0

    print(f"\o/ <-- customer\nhere's your bitch lasagna sir\n{burger[1]}")
    time.sleep(1)
    print('...')
    time.sleep(random.randint(1,3))

    ratings = {
        90: "Very nice!",
        75: "good",
        50: "run of the mill. good'nuff",
        25: "it sucks, but i'll pay",
        10: "tf? i won't pay for this crap",
        0: "BLEGH"
    }
    for k in ratings:
        if final_stats >= k:
            print(ratings[k])
            break
    
    print(f'cash earned: {final_price}')
    print(final_stats)

    return final_price, rate


##############################################################################################################

#####################
# STATION FUNCTIONS #
#####################


def grillStation():
    global comandoChapa
    global grill

    printStationMessage("a", "WELCOME TO DA GRILLIN' STATION!!!", """0: colocar hamburguer
    1: virar hamburguer
    2: tirar hamburguer
    3: atualizar dos hamburgueres""")
    for index, patty in enumerate(grill):
        print(f'Status do burgão {index}:')
        print(f'- Topo: {patty[1]}%')
        print(f'- Fundo: {patty[0]}%')
    
    command = input('> ')
    if command.isnumeric():
        if command == "0":
            grill.append([0, 0])
            burgerTimeCounter(len(grill) - 1) ## placeholder function call
        elif command == "1" or command == "2":
            if len(grill) > 1:
                for i in len(grill):
                    print(f"{i}: {grill[i]}")
                pattyToActOn = input('which burger do you want to flip?\n> ' if command == "1" else 'which burger do you want to remove?\n> ')
                comandoChapa = f'{pattyToActOn}{command}'
        else:
            print('invalid command you fucking donkey')
            grillStation()
    else:
        if command == "v":
            viewOrders()
        else:
            navigation("a", command)


    # incrementar a taxa de aquecimento do hamburguer 1.5x a cada segundo enquanto no grill
    # saindo de 0% ate possivelmente 100 em ambos os lados
    # vou ver como e no jogo original a cada quantos seg esquenta 1%
    ## ok
    ## é uma boa acho


def buildStation():
    ## player can only assemble one burger at a time
    ## but they can have multiple assembled burgers in storage.
    global burgers
    global asmbIng
    global cookedPatties
    burger = ''
    pattyToAdd = 0
    
    printStationMessage("b", "MOUNT (idk how to say this in english) THE BURGER TIME!\nWELCOME TO DA BUILDIN' STATION!!!", """0: down-bread
    1: top-bread
    2: burger
    3: cheese
    4: lettuce
    5: tomato""")
    print('the assembling ends when you put the top-bread.\n')
    print(burger)
    command = input('> ')

    if command.isnumeric():
        try:
            command = int(command)
            ## hola
            ## achei q tava jantando ainda
            ## mukbang 

            ## kkkkkkkk
            ## ok, td bem
            ## mas assim
            ## o codigo assincrono tá o equivalente de um emaranhado de fio do lado de trás de um pc de lanhouse
            ## tipo o do lab 2
            ## kkkkkk
            ## to vendo aq como faz pra executar uma função e só tipo, deixar ela rodando e ser feliz e independente sem ter q alguma função esperar por ela
            ## ainda n consegui achar como faz isso
            ## mas aí acho q ela acabaria parando o código :pensive:
            ## the code must go on
            #kkkkkkkk
            ## pera, vou ver aq outros módulos além do asyncio
            ## tem um aq chamado "multiprocessing" acho q parece promissor

            # kkkkkkkkkkkk mukbang
            # eu fui relaxar
            # cara q preguiça de fazer esse ascii
            # vou fazer só a logo msm, o resto a gente reparte
            # kkkkkk
            # ss
            # e se vc deixar uma função q n faz nada esperando por ela? >:)
            # vsf() kapakapa
            # acho q parece epico
            # ok kkkk
            if (asmbIng[6][0] == 0 and command != 0): ## if down-bread hasn't been put down and player put down something else (error condition)
                if command == 1: ## player tries to put down top-bread first (tries to complete the burger even though it has nothing) 
                    raise Exception("where's the burger you dumbass?") ## merely cosmetical though, the line in the code below would be enough for this if -- davidf
                raise Exception('is the plate the new down-bread?') ## player put down an ingredient other than top-bread
            if (asmbIng[6][0] > 1): ## player tried to put down more than one down-bread
                raise Exception("this ain't no big mac, so don't put more than one down-breads, ok? (it'd be harder to code y'know)")

            if command == 2:
                if len(cookedPatties) > 0:
                    for index, somaDeCozimento in enumerate(cookedPatties):
                        print(f'patty {index}: {somaDeCozimento}% cozido')
                    if len(cookedPatties) > 1:
                        pattyToAdd = int(input('which patty do you want to add to the burger?\n> '))
                    asmbIng[6][6] = somaDeCozimento
                    cookedPatties.pop(pattyToAdd)
                else:
                    raise Exception("i sense a stifling lack of COOKED PATTIES in this build station...")
                
            asmbIng[6][command] += 1 ## increments to appropriate ingredient counter

            burger = f'{asmbIng[command]:^10}\n{burger}'
            print(burger)

            if asmbIng[6][1] == 1:
                burgers.append(asmbIng[6])
                asmbIng[6] = [0, 0, 0, 0, 0, 0, 0]

        except Exception as e: ## prints the exception
            print(f'wth is possibly out of the desired behaviour within you, kindly? {e}')

        finally:
            buildStation()
    else:
        navigation("b", command)


def checkoutStation():
    global orders
    global burgers
    global customersWaiting
    ing = {0: 'burger', 1: 'cheese', 2: 'lettuce', 3: 'tomato', 4: [0, 0, 0, 0]}
    customerToGiveBurgerTo = 0
    burgerToGive = 0

    printStationMessage("c", "yo welcome to where we store the day's dolla dolla bills", """0: entregar pedido do cliente
    """)
    if customersWaiting > 0:
        print(f'There are customers WAITING FOR SERVICE YOU MORON! {customersWaiting}, to be exact.')
        print(f'1: serve customer')
    else:
        print('No customers waiting to be served. *For now*.')

    command = input('> ')


    if command == "0":
        if len(orders) > 0:

            for orderIndex, order in enumerate(orders):
                print(f'there are {len(orders)} orders waiting for your utterly incompetent ass:')
                print(f'{orderIndex}: Pedido do cliente {order[1]}, contendo:')

                for ingIndex, ingQuantity in enumerate(order[0]):
                    print(f'{ingQuantity} {ing[ingIndex]}')

            if len(orders) > 1:
                customerToGiveBurgerTo = int(input("which customer do you want to give the burger to?\n> "))
            if len(burgers) > 1:
                burgerToGive = int(input(f"you have more than one burger ready to go! which one do you want to give to {orders[customerToGiveBurgerTo][1]}?"))

            rateBurger(orders[customerToGiveBurgerTo], burgers[burgerToGive], ingameTime - orders[3])
            burgers.pop(burgerToGive)
            orders.pop(customerToGiveBurgerTo)

        else:
            print('no customers waiting for their burger jackass')


    elif command == "1":
        if customersWaiting:
            orders.append(makeOrder())

            print('\n\o/ <-- customer \nyo i wanna a burger with:')
            for ind, val in enumerate(orders[-1]):
                if (val > 0):
                    print(f'{val} {ing[ind]}')
            input('The customer will be waiting! Press any key to continue... ')
            checkoutStation()
        else:
            print('i said no customers were waiting to be served you dumbass')

    else:
        navigation("c", command)


##############################################################################################################

########
# MAIN #
########

def startGame():
    global size
    global days
    if days % 2 == 0: 
        size += 1
    
    nCustomers = random.randint(2, 4)
    for _ in range(nCustomers):
        clients = random.randint(2, 4) # ideia: clientes proporcionais ao nível de avaliação do restaurante (relacionado a variavel rate da func acima)


    print(f'DAY {days + 1}')

    while(ingameTime < 180): ## dia duraria 3 minutos (valor placeholder)
        print('...')
        time.sleep(random.randint(1, 5))
        ## aqui o player começa no caixa e pode navegar para a build station 
        ## (onde monta os hamburgueres) ou cozinha (onde frita) 

        ## para criar um bolo de funções assíncronas:
            # funcao1 = loop.create_task(nome_da_funcao())
            # funcao2 = loop.create_task(nome_da_funcao())
            # await asyncio.wait([funcao1, funcao2])

        order = makeOrder(2**size)
        counter_start = time.time()
        burger = buildStation()
        counter_end = time.time()

        cash_n_rate = rateBurger(order, burger, int(counter_start - counter_end))
    
    days += 1
    if days < 6:
        startGame()
    
    
while True:
    startGame()
    if input('quer jogar dnv?') == 1: 
        days, size = 0
        break

##############################################################################################################

# loop = asyncio.get_event_loop()
# loop.run_until_complete(startGame())